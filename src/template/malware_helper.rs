use super::helpers;

/// Plugin IDs that indicate malware detections.
///
/// This list mirrors the canonical IDs used by the legacy Ruby
/// implementation. It can be extended as new malware checks are
/// introduced.
pub const MALWARE_PLUGIN_IDS: &[i32] = &[
    34221, // Conficker Worm Detection (uncredentialed check)
    59275, // Malicious Process Detection
];

/// Plugin IDs specific to Conficker detections.
pub const CONFICKER_PLUGIN_IDS: &[i32] = &[
    34221,
];

/// Return `true` if the provided plugin ID corresponds to a malware finding.
pub fn has_malware_finding(plugin_id: i32) -> bool {
    MALWARE_PLUGIN_IDS.contains(&plugin_id)
}

/// Render a section describing Conficker malware infections.
pub fn conficker_section(hosts: &[&str]) -> String {
    if hosts.is_empty() {
        "No Conficker infections detected.".to_string()
    } else {
        let mut lines = Vec::new();
        lines.push(helpers::heading2("Conficker Infections"));
        for h in hosts {
            lines.push(format!("- {h}"));
        }
        lines.join("\n")
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn detects_malware_plugins() {
        assert!(has_malware_finding(34221));
        assert!(has_malware_finding(59275));
        assert!(!has_malware_finding(1));
    }

    #[test]
    fn no_conficker_infections() {
        assert_eq!(conficker_section(&[]), "No Conficker infections detected.");
    }

    #[test]
    fn list_conficker_infections() {
        let out = conficker_section(&["h1", "h2"]);
        assert!(out.contains("Conficker Infections"));
        assert!(out.contains("h1"));
        assert!(out.contains("h2"));
    }
}
